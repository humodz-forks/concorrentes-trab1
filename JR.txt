#include <stdio.h>

float erro (float *X, float *OLD_X, int J_ORDER)
{
	float ERRO = 0;
	float diferenca;
	for (int i = 0 ; i < J_ORDER; ++i)
	{
		diferenca = (OLD_X)? X[i] - OLD_X[i] : X[i];
		if(diferenca < 0) diferenca = -diferenca;
		if(diferenca > ERRO) ERRO = diferenca;
	}
	return ERRO;
}


int main ()
{
	int J_ORDER, J_ROW_TEST, J_ITE_MAX;
	float J_ERROR;
	float **MA, *MB, *X, *OLD_X;
	
	/* Inicio do programa - leitura dos valores iniciais */
	
	scanf ("%d %d %f %d", &J_ORDER, &J_ROW_TEST, &J_ERROR, &J_ITE_MAX);
	MA = (float **) malloc (sizeof(float *)*J_ORDER);
	MB = (float *) malloc (sizeof(float )*J_ORDER);
	X = (float *) malloc (sizeof(float )*J_ORDER);
	OLD_X = (float *) malloc (sizeof(float )*J_ORDER);
	
	/* Alocação da matrizes A*/
	for(int i = 0; i<J_ORDER; ++i)
	{
		MA[i] = (float *) malloc (sizeof(float)*J_ORDER);
	}
	
	/* Leitura dos valores de A*/
	for(int i = 0; i< J_ORDER; ++i)
	{
		for (int j = 0; j<J_ORDER ; ++j)
		{
			scanf ("%f", &MA[i][j]);
		}
	}
	
	/* Leitura dos valores de B*/
	for(int i = 0; i<J_ORDER; ++i)
	{
		scanf ("%f", &MB[i]);
	}
	
	
	/* Encontra as matrizes L*, I, R* de dentro da matrix MA */
	for(int i = 0; i< J_ORDER; ++i)
	{
		for (int j = 0; j<J_ORDER ; ++j)
		{
			MA[i][j]/=MA[i][i];
		}
		MB[i]/=MA[i][i]; /* Encontra o vetor MB* */
		MA[i][i] = 0; /*zera a diagonal principal */
	}
	
	/* Processo iterativo do método Jacobi-Richardson
	
	Iteração inicial, X é inicializado com o valor de MB* */
	printf("Iteracao\t");
	for(int i =0; i< J_ORDER; i++)
	{
		X[i]=MB[i];
	}
	printf("Erro\n");
	float ERRO = erro(X,NULL, J_ORDER);
	for (int k = 1; k < J_ITE_MAX && ERRO < J_ERROR; ++j)
	{
		
		for(int i = 0; i < J_ORDER; ++i)
		{
			OLD_X[i] = X[i];
			X[i] = B[i];
			for(int j=0; j<J_ORDER; ++j)
			{
				X[i]-=(X[j]*MA[i][j]);
			}
		}
		ERRO = erro(X,OLD_X, J_ORDER);
	}
	
	
	/* Encerramento do programa - Liberação de memória */
	for(int i = 0; i<J_ORDER; ++i)
	{
		free(MA[i]);
	}
	free(MA);
	free(MB);
	free(X);
  
	return 0;
}